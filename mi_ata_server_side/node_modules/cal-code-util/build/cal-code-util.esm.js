/**
* @file Aramaic CAL code transliteration utilities
* @version 1.1.7
* @author Greg Borota
* @copyright (c) 2017 Greg Borota.
* @license MIT
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*/

// https://peshitta.github.io
// https://sedra.bethmardutho.org/about/fonts
// http://cal1.cn.huc.edu/searching/fullbrowser.html

import { clearDotting, getSort, hasDotting } from 'aramaic-mapper';

var obj;
/** @module calCodeUtil */
/**
 * CAL consonant name to value map
 * @constant
 * @type { Object.<string, string> }
 */
var consonantsByName = Object.freeze(
  Object.create(null, {
    alaph: { value: ')', enumerable: true },
    beth: { value: 'b', enumerable: true },
    gamal: { value: 'g', enumerable: true },
    dalath: { value: 'd', enumerable: true },

    he: { value: 'h', enumerable: true },
    waw: { value: 'w', enumerable: true },
    zayn: { value: 'z', enumerable: true },

    heth: { value: 'x', enumerable: true },
    teth: { value: 'T', enumerable: true },
    yod: { value: 'y', enumerable: true },

    kaph: { value: 'k', enumerable: true },
    lamadh: { value: 'l', enumerable: true },
    mim: { value: 'm', enumerable: true },
    nun: { value: 'n', enumerable: true },

    semkath: { value: 's', enumerable: true },
    e: { value: '(', enumerable: true },
    pe: { value: 'p', enumerable: true },
    sadhe: { value: 'c', enumerable: true },

    qoph: { value: 'q', enumerable: true },
    resh: { value: 'r', enumerable: true },
    shin: { value: '$', enumerable: true },
    taw: { value: 't', enumerable: true },

    peReversed: { value: 'P', enumerable: true },
    sin: { value: '&', enumerable: true }
  })
);

var l = consonantsByName;
/**
 * CAL consonants
 * @constant
 * @type { string[] }
 */
var consonants = Object.freeze([
  // abgad
  l.alaph,
  l.beth,
  l.gamal,
  l.dalath,

  // hawaz
  l.he,
  l.waw,
  l.zayn,

  // ḥaṭy
  l.heth,
  l.teth,
  l.yod,

  // kalman
  l.kaph,
  l.lamadh,
  l.mim,
  l.nun,

  // saʿpac
  l.semkath,
  l.e,
  l.pe,
  l.sadhe,

  // qarshat
  l.qoph,
  l.resh,
  l.shin,
  l.taw
]);

/**
 * Extra CAL consonants specific to Palestinian or Hebrew
 * @constant
 * @type { string[] }
 */
var extraConsonants = [
  l.peReversed, // Palestinian Syriac P
  l.sin // Hebrew Sin
];

/**
 * Base consonants + extra consonants
 * @constant
 * @type { string[] }
 */
var allConsonants = Object.freeze(consonants.concat(extraConsonants));

/**
 * CAL vowel name to value map
 * @constant
 * @type { Object.<string, string> }
 */
var vowelsByName = Object.freeze(
  Object.create(null, {
    pthaha: { value: 'a', enumerable: true },
    zqapha: { value: 'o', enumerable: true },
    rbasa: { value: 'e', enumerable: true },
    hbasa: { value: 'i', enumerable: true },
    esasa: { value: 'u', enumerable: true },

    zlama: { value: 'E', enumerable: true },
    rwaha: { value: 'O', enumerable: true }
  })
);

var v = vowelsByName;
/**
 * CAL common vowels
 * @constant
 * @type { string[] }
 */
var commonVowels = Object.freeze([
  v.pthaha,
  v.zqapha,
  v.rbasa,
  v.hbasa,
  v.esasa
]);

/**
 * CAL eastern/hebrew only vowels
 * @constant
 * @type { string[] }
 */
var easternVowels = Object.freeze([v.zlama, v.rwaha]);

/**
 * CAL vowels including Eastern/Hebrew ones
 * @constant
 * @type { string[] }
 */
var vowels = Object.freeze(commonVowels.concat(easternVowels));

/**
 * Sedra/CAL diacritic name map
 * 1. qushaya: __'__ - dot above
 * 2. rukkakha: __,__ - dot below
 * 3. lineaOccultans: **_** - linea occultans
 * 4. seyame: __*__ - seyame, rebwe
 * @constant
 * @type { Object.<string, string> }
 */
var diacriticsByName = Object.freeze(
  Object.create(null, {
    qushaya: { value: "'", enumerable: true },
    rukkakha: { value: ',', enumerable: true },
    lineaOccultans: { value: '_', enumerable: true },
    seyame: { value: '*', enumerable: true }
  })
);

var d = diacriticsByName;
/**
 * Sedra/CAL diacritic characters:
 * 1. __'__ dot above, Qushaya
 * 2. __,__ dot below, Rukkakha
 * 3. **_** line under
 * 4. __*__ Seyame
 * @constant
 * @type { string[] }
 */
var diacritics = Object.freeze([
  d.qushaya,
  d.rukkakha,
  d.lineaOccultans,
  d.seyame
]);

/**
 * CAL to ordinal ASCII value. Used for sorting:
 * a b c d e f g h i j k l m n o p q r s t u v
 * w x y z { | }
 * @constant
 * @type { Object.<string, string> }
 */
var letterAsciiMap = Object.freeze(
  Object.create(null, ( obj = {}, obj[l.alaph] = { value: 'a', enumerable: true }, obj[l.beth] = { value: 'b', enumerable: true }, obj[l.gamal] = { value: 'c', enumerable: true }, obj[l.dalath] = { value: 'd', enumerable: true }, obj[l.he] = { value: 'e', enumerable: true }, obj[l.waw] = { value: 'f', enumerable: true }, obj[l.zayn] = { value: 'g', enumerable: true }, obj[l.heth] = { value: 'h', enumerable: true }, obj[l.teth] = { value: 'i', enumerable: true }, obj[l.yod] = { value: 'j', enumerable: true }, obj[l.kaph] = { value: 'k', enumerable: true }, obj[l.lamadh] = { value: 'l', enumerable: true }, obj[l.mim] = { value: 'm', enumerable: true }, obj[l.nun] = { value: 'n', enumerable: true }, obj[l.semkath] = { value: 'o', enumerable: true }, obj[l.e] = { value: 'p', enumerable: true }, obj[l.pe] = { value: 'q', enumerable: true }, obj[l.sadhe] = { value: 'r', enumerable: true }, obj[l.qoph] = { value: 's', enumerable: true }, obj[l.resh] = { value: 't', enumerable: true }, obj[l.shin] = { value: 'u', enumerable: true }, obj[l.taw] = { value: 'v', enumerable: true }, obj[l.peReversed] = { value: 'q', enumerable: true }, obj[l.sin] = { value: 'u', enumerable: true }, obj[v.pthaha] = { value: 'w', enumerable: true }, obj[v.zqapha] = { value: 'x', enumerable: true }, obj[v.rbasa] = { value: 'y', enumerable: true }, obj[v.zlama] = { value: 'z', enumerable: true }, obj[v.hbasa] = { value: '{', enumerable: true }, obj[v.esasa] = { value: '|', enumerable: true }, obj[v.rwaha] = { value: '}', enumerable: true }, obj[d.qushaya] = { value: '', enumerable: true }, obj[d.rukkakha] = { value: ',', enumerable: true }, obj[d.lineaOccultans] = { value: '', enumerable: true }, obj[d.seyame] = { value: '', enumerable: true }, obj))
);

/**
 * Common punctuation
 * @constant
 * @type { Array.<string> }
 */
var punctuation = Object.freeze([';', '?', '!', '.', '-', ':']);

/**
 * Vowels and diacritics: used for consonantal only mapping
 * @constant
 * @type { Array.<string> }
 */
var dotting = Object.freeze(vowels.concat(diacritics));

/**
 * Bdwl consonants
 * @constant
 * @type { Array.<string> }
 */
var bdwl = Object.freeze([
  consonantsByName.beth,
  consonantsByName.dalath,
  consonantsByName.waw,
  consonantsByName.lamadh
]);

/**
 * Is character c a CAL consonant
 * @param { string } c input character
 * @returns { boolean } true if c is CAL consonant
 */
var isConsonant = function (c) { return allConsonants.indexOf(c) > -1; };

/**
 * Is character c a CAL vowel
 * @param { string } c input character
 * @returns { boolean } true if c is CAL vowel
 */
var isVowel = function (c) { return vowels.indexOf(c) > -1; };

/**
 * Is character c a diacritic? Same characters used for both Sedra 3 and CAL.
 * @param { string } c input character
 * @returns { boolean } true if c is a diacritic
 */
var isDiacritic = function (c) { return diacritics.indexOf(c) > -1; };

/**
 * Is character c a common punctuation char?
 * @param { string } c input character
 * @returns { boolean } true if c is common punctuation
 */
var isPunctuation = function (c) { return punctuation.indexOf(c) > -1; };

/**
 * Returns true if c is dotting character
 * @param { string } c input character
 * @returns { boolean } true if c is dotting
 */
var isDotting = function (c) { return dotting.indexOf(c) > -1; };

/**
 * Return true if input word has vowels or diacritics
 * @param { string } word input CAL code word
 * @returns { boolean } true if word has vowels or diacritics
 */
var isDotted = hasDotting(isDotting);

/**
 * Remove dotting (vowels and diacritics), leaving consonantal word only.
 * @param { string } word input word to be processed
 * @returns { string } consonantal word
 */
var removeDotting = clearDotting(isDotting);

/**
 * Comparator function to be used for sorting CAL words
 * @static
 * @param { string } word1 first word to compare
 * @param { string } word2 second word to compare
 * @returns { number } -1, 0, 1 depending on word sorting
 */
var sort = getSort(letterAsciiMap, isConsonant);

/**
 * Return true if word is bdwl prefixed starting with index
 * @static
 * @param { string } word word to test
 * @param { number } index position in word to start checking from
 * @returns { boolean } true if word is bdwl prefixed
 */
var isBdwlPrefix = function (word, index) {
  if (index < 0) {
    return false;
  }
  for (var i = index; i >= 0; i--) {
    var c = word.charAt(i);
    if (isConsonant(c) && bdwl.indexOf(c) === -1) {
      return false;
    }
  }
  return true;
};

export { consonantsByName, consonants, extraConsonants, allConsonants, vowelsByName, commonVowels, easternVowels, vowels, diacriticsByName, diacritics, letterAsciiMap, punctuation, dotting, bdwl, isConsonant, isVowel, isDiacritic, isPunctuation, isDotting, isDotted, removeDotting, sort, isBdwlPrefix };
