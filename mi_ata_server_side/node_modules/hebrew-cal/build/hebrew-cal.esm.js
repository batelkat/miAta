/**
* @file Convert Hebrew Ashuri to CAL code
* @version 1.0.2
* @author Greg Borota
* @copyright (c) 2017 Greg Borota.
* @license MIT
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*/

// https://peshitta.github.io
// https://sedra.bethmardutho.org/about/fonts
// http://cal1.cn.huc.edu/searching/fullbrowser.html

import { Mapper, Writing } from 'aramaic-mapper';
import { allConsonants, allDiacritics, allVowels, cantillationDiacritics, isBegadkepat, isDotted } from 'hebrew-code-util';
import { consonants, diacriticsByName } from 'cal-code-util';

/** @module hebrewCal */
/**
 * @private
 * Hebrew source writing
 * @const
 * @type { Writing }
 */
var hebrewWriting = new Writing(
  Object.freeze(
    allConsonants.concat([
      '\u2135', // ℵ alef symbol
      '\u2136', // ℶ bet symbol
      '\u2137', // ℷ gimel symbol
      '\u2138' // ℸ dalet symbol
    ])
  ),
  allVowels,
  allDiacritics
);

var cantillations = [];
for (var i = 0, len = cantillationDiacritics.length; i < len; i++) {
  cantillations.push('');
}

/**
 * @private
 * CAL destination writing
 * @const
 * @type { Writing }
 */
var calWriting = new Writing(
  Object.freeze(
    consonants.concat(
      [
        'k', // ך HEBREW LETTER FINAL KAF
        'm', // ם HEBREW LETTER FINAL MEM
        'n', // ן HEBREW LETTER FINAL NUN
        'p', // ף HEBREW LETTER FINAL PE
        'c' // ץ HEBREW LETTER FINAL TSADI
      ]
        .concat([
          'ww', // װ HEBREW LIGATURE YIDDISH DOUBLE VAV = tsvey vovn
          'wy', // ױ HEBREW LIGATURE YIDDISH VAV YOD
          'yy' // ײ HEBREW LIGATURE YIDDISH DOUBLE YOD = tsvey yudn
        ])
        .concat([
          ')', // ℵ alef symbol
          'b', // ℶ bet symbol
          'g', // ℷ gimel symbol
          'd' // ℸ dalet symbol
        ])
    )
  ),
  Object.freeze([
    'a', //  ַ HEBREW POINT PATAH
    'o', //  ָ HEBREW POINT QAMATS
    'e', //  ֵ HEBREW POINT TSERE
    'i', //  ִ HEBREW POINT HIRIQ
    '' //  ּ HEBREW POINT DAGESH OR MAPIQ: callback will distinguish
  ])
    .concat([
      'E', //  ֶ HEBREW POINT SEGOL
      'O' //  ֺHEBREW POINT HOLAM HASER FOR VAV
    ])
    .concat([
      'O', //  ֹ HEBREW POINT HOLAM
      'u', //  ֻ HEBREW POINT QUBUTS
      '', //  ְ HEBREW POINT SHEVA
      'E', //  ֱ HEBREW POINT HATAF SEGOL
      'a', //  ֲ HEBREW POINT HATAF PATAH
      'O', //  ֳ HEBREW POINT HATAF QAMATS
      'O' //  ׇ HEBREW POINT QAMATS QATAN → \u05B8 hebrew point qamats
    ]),
  Object.freeze(
    [
      '', //  ֽ HEBREW POINT METEG
      diacriticsByName.rukkakha, //  ֿ HEBREW POINT RAFE
      '', //  ׁHEBREW POINT SHIN DOT: callback will handle
      '', //  ׂHEBREW POINT SIN DOT: callback will handle
      '', //  ׄ HEBREW MARK UPPER DOT
      '' //  ׅ HEBREW MARK LOWER DOT
    ].concat(cantillations)
  )
);

var dagesh = '\u05BC'; //  ּ HEBREW POINT DAGESH OR MAPIQ = shuruq
var rafe = '\u05BF'; //  ֿ HEBREW POINT RAFE
var shin = '\u05E9'; // ש HEBREW LETTER SHIN
var sinDot = '\u05C2'; //  ׂHEBREW POINT SIN DOT
var vav = '\u05D5'; // ו HEBREW LETTER VAV
var mapChar = function (c, fromTo) {
  var m = fromTo[c];
  return m || m === '' ? m : c;
};

/**
 * @private
 * Customized mapping callback
 * @param { string } word input word
 * @param { number } i current index in the word
 * @param { Object.<string, string> } fromTo mapping dictionary
 * @param { Object } wordProps optional word settings
 * @returns { string } Call mapped char
 */
var callback = function (word, i, fromTo, wordProps) {
  var c = word.charAt(i);
  var n = word.charAt(i + 1);
  if (wordProps.isDotted && isBegadkepat(c)) {
    var b = mapChar(c, fromTo);
    //  ּ HEBREW POINT DAGESH OR MAPIQ
    if (n === dagesh) {
      return b + diacriticsByName.qushaya; // not handling begadkepat dagesh forte
    }
    if (n === rafe || i === word.length - 1) {
      return b;
    }
    return b + diacriticsByName.rukkakha;
  }
  switch (c) {
    case dagesh: //  ּ HEBREW POINT DAGESH OR MAPIQ and ו HEBREW LETTER VAV
      return word.charAt(i - 1) === vav ? 'u' : '';
    case shin: // ש HEBREW LETTER SHIN and ׂHEBREW POINT SIN DOT
      return n === sinDot ? '&' : '$';
    default:
      return mapChar(c, fromTo);
  }
};

/**
 * Hebrew Mapper
 * @const
 * @type { Mapper }
 */
var mapper = new Mapper(hebrewWriting, calWriting, callback);
mapper.multiples = Object.freeze(['b,', 'g,', 'd,', 'k,', 'p,', 't,']);

/**
 * Convert from Hebrew Unicode to CAL
 * @static
 * @param { string } word input word in Hebrew Unicode
 * @returns { string } the input word converted to CAL code
 */
var toCal = function (word) { return mapper.map(
    word,
    Object.freeze(
      Object.create(null, {
        isDotted: { value: isDotted(word), enumerable: true }
      })
    )
  ); };

export { mapper, toCal };
