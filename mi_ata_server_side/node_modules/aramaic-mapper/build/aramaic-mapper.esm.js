/**
* @file Generic support for mapping between Aramaic writing systems
* @version 1.1.5
* @author Greg Borota
* @copyright (c) 2017 Greg Borota.
* @license MIT
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*/

// https://peshitta.github.io
// https://sedra.bethmardutho.org/about/fonts
// http://cal1.cn.huc.edu/searching/fullbrowser.html

/** @module aramaicMapper */
/**
 * @class Writing
 * @classdesc Tuple for storing an Aramaic writing system:
 * * Consonants are expected to be in the standard Aramaic order.
 * * Vowels are expected to be in the Sedra [ a o e i u ] order + optional
 *   Eastern/Hebrew short E and long O in positions 6 and 7 respectively.
 * * Diacritics, if provided, should follow Sedra [' , _  *] order. They are
 *   Qushaya, Rukkakha, Linea Occultans and Seyame respectively.
 *   Other diacritics like verb and homograph dots or Hebrew Sheva, if
 *   supported, should be added after the above.
 * * Optionally punctuation and other characters could be added for mapping.
 *
 * The main idea is that each mapped character should be in the same
 * position in the _to_ Writing system as the _from_ Writing system.
 * @static
 * @constructor
 * @param { string[] } consonants consonant list in the standard aramaic order
 * @param { string[] } vowels vowel list in the Sedra order
 * @param { string[] } diacritics optional diacritics list in the Sedra order
 * @param { string[]|undefined } punctuation optional punctuation list
 * @param { string[]|undefined } other optional other symbols like crosses, etc.
 */
function Writing(consonants, vowels, diacritics, punctuation, other) {
  this.consonants = consonants;
  this.vowels = vowels;
  this.diacritics = diacritics;
  this.punctuation = punctuation;
  this.other = other;
}

/**
 * @static
 * @callback mapCallback
 * Callback to replace generic one-to-one mapping
 * @param { string } word input word to be mapped
 * @param { number }  index - index of the current character to be mapped
 * @param { Object.<string, string> } fromTo - character mapping hash from
 * @param { Object } wordProps optional word properties hash
 * base Writing to mapped Writing
 * @returns { string } the mapped string for c - could be longer than one
 * character
 */

/**
 * @class Mapper
 * @classdesc Map from a base writing system to another system.
 * The optional `mapCallback` when called will be provided following arguments:
 * * word - the word to be mapped
 * * index - index of the current character to be mapped
 * * fromTo - character mapping hash from base Writing to mapped Writing
 *
 * `mapCallback` needs to be provided only when the simple one to one mapping
 * between writing systems is not enough, and custom mapping needs to be
 * implemented instead.
 * @static
 * @constructor
 * @param { Writing } fromWriting base writing system
 * @param { Writing } toWriting writing system to map to
 * @param { mapCallback|undefined } mapCallback optional map callback
 */
function Mapper(fromWriting, toWriting, mapCallback) {
  var this$1 = this;

  /**
   * Source writing system to be mapped
   * @alias module:aramaicMapper.Mapper#fromWriting
   * @type { Writing }
   */
  this.fromWriting = fromWriting;

  /**
   * Destination writing system to map to
   * @alias module:aramaicMapper.Mapper#toWriting
   * @type { Writing }
   */
  this.toWriting = toWriting;

  /**
   * Character mapping hash from base Writing to mapped Writing
   * @alias module:aramaicMapper.Mapper#fromTo
   * @type { Object.<string, string> }
   */
  this.fromTo = Object.create(null);

  /**
   * Mapped multiple char sequences that map to a single `fromWriting` char.
   * Used to move only 1 character ahead, instead of length of mapped string.
   * @alias module:aramaicMapper.Mapper#multiples
   * @type { Array.<string> }
   */
  this.multiples = [];

  /**
   * Checked callback - to make sure it is a function
   * @private
   * @type { mapCallback }
   */
  var callback = typeof mapCallback === 'function' ? mapCallback : undefined;

  for (var i = 0, clen = fromWriting.consonants.length; i < clen; i++) {
    var fc = fromWriting.consonants[i];
    var tc = toWriting.consonants[i];
    Object.defineProperty(this$1.fromTo, fc, { value: tc, enumerable: true });
  }

  for (var j = 0, vlen = fromWriting.vowels.length; j < vlen; j++) {
    var fv = fromWriting.vowels[j];
    var tv = toWriting.vowels[j];
    Object.defineProperty(this$1.fromTo, fv, { value: tv, enumerable: true });
  }

  if (fromWriting.diacritics && toWriting.diacritics) {
    for (var k = 0, dlen = fromWriting.diacritics.length; k < dlen; k++) {
      var fd = fromWriting.diacritics[k];
      var td = toWriting.diacritics[k];
      Object.defineProperty(this$1.fromTo, fd, { value: td, enumerable: true });
    }
  }

  if (fromWriting.punctuation && toWriting.punctuation) {
    for (var l = 0, plen = fromWriting.punctuation.length; l < plen; l++) {
      var fp = fromWriting.punctuation[l];
      var tp = toWriting.punctuation[l];
      Object.defineProperty(this$1.fromTo, fp, { value: tp, enumerable: true });
    }
  }

  if (fromWriting.other && toWriting.other) {
    for (var m = 0, olen = fromWriting.other.length; m < olen; m++) {
      var fo = fromWriting.other[m];
      var to = toWriting.other[m];
      Object.defineProperty(this$1.fromTo, fo, { value: to, enumerable: true });
    }
  }

  Object.freeze(this.fromTo);

  /**
   * Map word from a base writing system to another system
   * @alias module:aramaicMapper.Mapper#map
   * @param { string } word input word to be mapped
   * @param { Object } wordProps optional word settings - to be passed to callback
   * @returns { string } mapped word
   */
  this.map = function (word, wordProps) {
    if (!word) {
      return word;
    }
    var c = '';
    var sb = '';
    for (
      var i = 0, len = word.length, mc = (void 0);
      i < len;
      i +=
        mc && mc.length && mc.length > 0 && this$1.multiples.indexOf(mc) === -1
          ? mc.length
          : 1
    ) {
      if (callback) {
        mc = callback(word, i, this$1.fromTo, wordProps);
      } else {
        c = word.charAt(i);
        mc = this$1.fromTo[c];
        if (!mc && mc !== '') {
          mc = c;
        }
      }
      sb += mc || '';
    }
    return sb;
  };
}

/**
 * Returns function which returns true if input word has vowels or diacritics.
 * @static
 * @param { function } isDotting (char => boolean) which checks if char is dotting
 * @returns { function } hasDotting (word => boolean) function logic
 */
var hasDotting = function (isDotting) { return function (word) {
  if (!word) {
    return false;
  }
  for (var i = 0, len = word.length; i < len; i++) {
    var c = word.charAt(i);
    if (isDotting(c)) {
      return true;
    }
  }
  return false;
}; };

/**
 * Returns a function to remove vowels and diacritics and keep the consonantal
 * skeleton only.
 * @static
 * @param { function } isDotting (char => boolean) which checks if char is dotting
 * @returns { function } clearDotting (word => word) function logic
 */
var clearDotting = function (isDotting) { return function (word) {
  if (!word) {
    return word;
  }

  var hasDots = false;
  var stack = [];
  for (var i = 0, len = word.length; i < len; i++) {
    var c = word.charAt(i);
    if (isDotting(c)) {
      hasDots = true;
    } else {
      stack.push(c);
    }
  }
  return hasDots ? stack.join('') : word;
}; };

/**
 * Convert word to consonantal and vocalised ASCII sort chars.
 * @private
 * @static
 * @param { string } word input word
 * @param { Object.<string, string> } letterAsciiMap letter to ASCII value map
 * @param { function } isConsonant function returning true if char is consonant
 * @returns { object } word converted as consonantal and vocalised ASCII sort
 */
var toAsciiSort = function (word, letterAsciiMap, isConsonant) {
  var con = '';
  var voc = '';
  for (var i = 0, len = word.length; i < len; i++) {
    var c = word.charAt(i);
    var m = letterAsciiMap[c];
    if (isConsonant(c)) {
      con += m || (m === '' ? '' : c);
    }
    voc += m || (m === '' ? '' : c);
  }
  return { con: con, voc: voc };
};

/**
 * Returns a function to be used for sorting words using the provided `letterAsciiMap`
 * @static
 * @param { Object.<string, string> } letterAsciiMap letter to ASCII value map
 * @param { function } isConsonant (char => boolean) Is character c a consonant
 * @returns { function } ((word1, word2) => number) function implementation
 */
var getSort = function (letterAsciiMap, isConsonant) { return function (word1, word2) {
  if (!word1 || !word2) {
    return !word1 && !word2 ? 0 : !word1 ? -1 : 1;
  }

  var ref = toAsciiSort(word1, letterAsciiMap, isConsonant);
  var c1 = ref.con;
  var v1 = ref.voc;
  var ref$1 = toAsciiSort(word2, letterAsciiMap, isConsonant);
  var c2 = ref$1.con;
  var v2 = ref$1.voc;
  if (c1 < c2) {
    return -1;
  }
  if (c1 > c2) {
    return 1;
  }

  if (c1 === v1 && c2 === v2) {
    return 0; // no dots
  }

  return v1 < v2 ? -1 : v1 > v2 ? 1 : 0;
}; };

export { Writing, Mapper, hasDotting, clearDotting, getSort };
